<HTML
><HEAD
><TITLE
>pack</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.41"><LINK
REL="HOME"
TITLE="PHP3 Manual"
HREF="manual.html"><LINK
REL="UP"
TITLE="Miscellaneous Functions"
HREF="ref.misc.html"><LINK
REL="PREVIOUS"
TITLE="leak"
HREF="function.leak.html"><LINK
REL="NEXT"
TITLE="register_shutdown_function"
HREF="function.register-shutdown-function.html"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PHP3 Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="function.leak.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="function.register-shutdown-function.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="FUNCTION.PACK"
>pack</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN12554"
></A
>pack -- pack data into binary string</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN12557"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><CODE
CLASS="FUNCDEF"
>string pack</CODE
>(string format, mixed [<SPAN
CLASS="OPTIONAL"
>args</SPAN
>]...);<P
></P
></DIV
><P
>     Pack given arguments into binary string according to
     <TT
CLASS="PARAMETER"
><I
>format</I
></TT
>. Returns binary string containing data.

    </P
><P
>     The idea to this function was taken from Perl and all formatting
     codes work the same as there. The format string consists of
     format codes followed by an optional repeater argument. The
     repeater argument can be either an integer value or * for
     repeating to the end of the input data. For a, A, h, H the repeat
     count specifies how many characters of one data argument are
     taken, for @ it is the absolute position where to put the next
     data, for everything else the repeat count specifies how many
     data arguments are consumed and packed into the resulting binary
     string. Currently implemented are
     <P
></P
><UL
><LI
><P
>a NUL-padded string</P
></LI
><LI
><P
>A SPACE-padded string</P
></LI
><LI
><P
>h Hex string, low nibble first</P
></LI
><LI
><P
>H Hex string, high nibble first</P
></LI
><LI
><P
>c signed char</P
></LI
><LI
><P
>C unsigned char</P
></LI
><LI
><P
>s signed short (always 16 bit, machine byte order)</P
></LI
><LI
><P
>S unsigned short (always 16 bit, machine byte order)</P
></LI
><LI
><P
>n unsigned short (always 16 bit, big endian
	byte order)</P
></LI
><LI
><P
>v unsigned short (always 16 bit, little
	endian byte order)</P
></LI
><LI
><P
>i signed integer (machine dependant size and
	byte order)</P
></LI
><LI
><P
>I unsigned integer (machine dependant size
	and byte order)</P
></LI
><LI
><P
>l signed long (always 32 bit, machine byte order)</P
></LI
><LI
><P
>L unsigned long (always 32 bit, machine byte order)</P
></LI
><LI
><P
>N unsigned long (always 32 bit, big endian
	byte order)</P
></LI
><LI
><P
>V unsigned long (always 32 bit, little endian
	byte order)</P
></LI
><LI
><P
>f float (machine dependent size and representation)</P
></LI
><LI
><P
>d double (machine dependent size and representation)</P
></LI
><LI
><P
>x NUL byte</P
></LI
><LI
><P
>X Back up one byte</P
></LI
><LI
><P
>@ NUL-fill to absolute position</P
></LI
></UL
>

     <TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
CLASS="EXAMPLE"
><TR
><TD
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 1. pack format string</B
></P
><PRE
CLASS="PROGRAMLISTING"
>$binarydata = pack("nvc*", 0x1234, 0x5678, 65, 66);</PRE
><P
>       The resulting binary string will be 6 bytes long and contain
       the byte sequence 0x12, 0x34, 0x78, 0x56, 0x41, 0x42.
     </P
></DIV
></TD
></TR
></TABLE
>

    </P
><P
>     Note that the distinction between signed and unsigned values only 
     affects the function <A
HREF="function.unpack.html"
><B
CLASS="FUNCTION"
>unpack()</B
></A
>, where as
     function <B
CLASS="FUNCTION"
>pack()</B
> gives the same result for
     signed and unsigned format codes.

    </P
><P
>     Also note that PHP internally stores integral values as signed
     values of a machine dependant size. If you give it an unsigned
     integral value too large to be stored that way it is converted to 
     a double which often yields an undesired result.

   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="function.leak.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="manual.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="function.register-shutdown-function.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>leak</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ref.misc.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>register_shutdown_function</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>